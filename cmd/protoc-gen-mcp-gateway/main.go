package main

import (
	"fmt"
	"strings"

	"github.com/linkbreakers-com/grpc-mcp-gateway/internal/annotations"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	opts := protogen.Options{}
	opts.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	var services []*protogen.Service
	for _, service := range file.Services {
		if hasAnnotatedMethods(service) {
			services = append(services, service)
		}
	}
	if len(services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_mcp.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-mcp-gateway. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P("import (")
	g.P("\t\"context\"")
	g.P("\t\"fmt\"")
	g.P()
	g.P("\t\"github.com/linkbreakers-com/grpc-mcp-gateway/runtime\"")
	g.P(")")
	g.P()

	for _, service := range services {
		generateService(g, service)
	}
}

func hasAnnotatedMethods(service *protogen.Service) bool {
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		if _, ok := annotations.ToolFromMethod(method.Desc); ok {
			return true
		}
	}
	return false
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName
	clientName := serviceName + "Client"

	g.P("// Register", serviceName, "MCPHandler registers stateless MCP tools for ", serviceName, ".")
	g.P("func Register", serviceName, "MCPHandler(mux *runtime.MCPServeMux, client ", clientName, ") {")
	g.P("\tif mux == nil {")
	g.P("\t\tpanic(\"mcp mux is nil\")")
	g.P("\t}")
	g.P("\tif client == nil {")
	g.P("\t\tpanic(\"grpc client is nil\")")
	g.P("\t}")
	g.P()

	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		tool, ok := annotations.ToolFromMethod(method.Desc)
		if !ok {
			continue
		}
		generateMethod(g, service, method, tool)
	}

	g.P("}")
	g.P()
}

func generateMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method, tool annotations.ToolOptions) {
	methodName := method.GoName

	toolName := tool.Name
	if toolName == "" {
		toolName = service.GoName + "." + methodName
	}
	toolTitle := tool.Title
	if toolTitle == "" {
		toolTitle = methodName
	}
	toolDescription := tool.Description
	if toolDescription == "" {
		toolDescription = normalizeComment(method.Comments.Leading.String())
	}

	g.P("\tmux.RegisterTool(&runtime.ToolHandler{")
	g.P("\t\tName: ", fmt.Sprintf("%q", toolName), ",")
	g.P("\t\tTitle: ", fmt.Sprintf("%q", toolTitle), ",")
	g.P("\t\tDescription: ", fmt.Sprintf("%q", toolDescription), ",")
	g.P("\t\tInputSchema: runtime.DefaultInputSchema(),")
	if tool.ReadOnly {
		g.P("\t\tReadOnly: true,")
	}
	if tool.Idempotent {
		g.P("\t\tIdempotent: true,")
	}
	if tool.Destructive {
		g.P("\t\tDestructive: true,")
	}
	g.P("\t\tHandler: func(ctx context.Context, args map[string]any) (any, error) {")
	g.P("\t\t\treq := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
	g.P("\t\t\tif err := runtime.DecodeArgs(args, req); err != nil {")
	g.P("\t\t\t\treturn nil, fmt.Errorf(\"invalid arguments: %v\", err)")
	g.P("\t\t\t}")
	g.P("\t\t\tresp, err := client.", methodName, "(ctx, req)")
	g.P("\t\t\tif err != nil {")
	g.P("\t\t\t\treturn nil, err")
	g.P("\t\t\t}")
	g.P("\t\t\treturn runtime.EncodeProto(resp)")
	g.P("\t\t},")
	g.P("\t})")
}

func normalizeComment(comment string) string {
	comment = strings.TrimSpace(comment)
	comment = strings.ReplaceAll(comment, "\n", " ")
	comment = strings.ReplaceAll(comment, "\r", " ")
	comment = strings.Join(strings.Fields(comment), " ")
	return comment
}
