package main

import (
	"fmt"
	"strings"

	"github.com/linkbreakers-com/grpc-mcp-gateway/internal/annotations"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	opts := protogen.Options{}
	opts.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	var services []*protogen.Service
	for _, service := range file.Services {
		if hasAnnotatedMethods(service) {
			services = append(services, service)
		}
	}
	if len(services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_mcp.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-mcp-gateway. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P("import (")
	g.P("\t\"context\"")
	g.P("\t\"fmt\"")
	g.P()
	g.P("\t\"github.com/linkbreakers-com/grpc-mcp-gateway/runtime\"")
	g.P()
	g.P("\t\"github.com/modelcontextprotocol/go-sdk/mcp\"")
	g.P(")")
	g.P()

	for _, service := range services {
		generateService(g, service)
	}

	g.P("func boolPtr(v bool) *bool {")
	g.P("\treturn &v")
	g.P("}")
}

func hasAnnotatedMethods(service *protogen.Service) bool {
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		if _, ok := annotations.ToolFromMethod(method.Desc); ok {
			return true
		}
	}
	return false
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName
	clientName := serviceName + "Client"

	g.P("// Register", serviceName, "MCPGateway registers MCP tools for ", serviceName, ".")
	g.P("func Register", serviceName, "MCPGateway(server *mcp.Server, client ", clientName, ") {")
	g.P("\tif server == nil {")
	g.P("\t\tpanic(\"mcp server is nil\")")
	g.P("\t}")
	g.P("\tif client == nil {")
	g.P("\t\tpanic(\"grpc client is nil\")")
	g.P("\t}")
	g.P()

	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		tool, ok := annotations.ToolFromMethod(method.Desc)
		if !ok {
			continue
		}
		generateMethod(g, service, method, tool)
	}

	g.P("}")
	g.P()
}

func generateMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method, tool annotations.ToolOptions) {
	serviceName := service.GoName
	methodName := method.GoName

	toolName := tool.Name
	if toolName == "" {
		toolName = serviceName + "." + methodName
	}
	toolTitle := tool.Title
	if toolTitle == "" {
		toolTitle = methodName
	}
	toolDescription := tool.Description
	if toolDescription == "" {
		toolDescription = normalizeComment(method.Comments.Leading.String())
	}

	g.P("\t{")
	g.P("\t\ttool := &mcp.Tool{")
	g.P("\t\t\tName: ", fmt.Sprintf("%q", toolName), ",")
	g.P("\t\t\tTitle: ", fmt.Sprintf("%q", toolTitle), ",")
	if toolDescription != "" {
		g.P("\t\t\tDescription: ", fmt.Sprintf("%q", toolDescription), ",")
	}
	if tool.ReadOnly || tool.Idempotent || tool.Destructive {
		g.P("\t\t\tAnnotations: &mcp.ToolAnnotations{")
		if tool.ReadOnly {
			g.P("\t\t\t\tReadOnlyHint: true,")
		}
		if tool.Idempotent {
			g.P("\t\t\t\tIdempotentHint: true,")
		}
		if tool.Destructive {
			g.P("\t\t\t\tDestructiveHint: boolPtr(true),")
		}
		g.P("\t\t\t},")
	}
	g.P("\t\t}")
	g.P("\t\tmcp.AddTool(server, tool, func(ctx context.Context, _ *mcp.CallToolRequest, args map[string]any) (*mcp.CallToolResult, any, error) {")
	g.P("\t\t\treq := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
	g.P("\t\t\tif err := runtime.DecodeArgs(args, req); err != nil {")
	g.P("\t\t\t\treturn runtime.ToolError(fmt.Sprintf(\"invalid arguments: %v\", err)), nil, nil")
	g.P("\t\t\t}")
	g.P("\t\t\tresp, err := client.", methodName, "(ctx, req)")
	g.P("\t\t\tif err != nil {")
	g.P("\t\t\t\treturn runtime.ToolError(err.Error()), nil, nil")
	g.P("\t\t\t}")
	g.P("\t\t\toutput, err := runtime.EncodeProto(resp)")
	g.P("\t\t\tif err != nil {")
	g.P("\t\t\t\treturn runtime.ToolError(fmt.Sprintf(\"failed to encode response: %v\", err)), nil, nil")
	g.P("\t\t\t}")
	g.P("\t\t\treturn nil, output, nil")
	g.P("\t\t})")
	g.P("\t}")
}

func normalizeComment(comment string) string {
	comment = strings.TrimSpace(comment)
	comment = strings.ReplaceAll(comment, "\n", " ")
	comment = strings.ReplaceAll(comment, "\r", " ")
	comment = strings.Join(strings.Fields(comment), " ")
	return comment
}
